# t1 = (1,) #tuple이 원소를 하나만 가질 경우에는 ',' 를 넣어줘야 tuple로 인식된다.
# t2 = (1,2,3)
# l1 = [1,2,3]
# t3 = tuple(l1)
# t4 = 123
# print(type(t1),(type(t2),(type(t3),(type(t4) #출력값 => <class 'tuple'>

#tuple은 값의 생성, 수정, 삭제가 불가능한 imutable한 자료형이다.
# t1 = (1,2,3,4)
# #삭제
# del t1[1] #결과 => TypeError: 'tuple' object dosen't support item deletion
# #수정
# t1[1] = 5

#딕셔너리 생성
# d1 = {"key":"value"}
# a = ["Hello"]
# b = ["Python"]
# d2 = dict(zip(a,b))
# print(d2, type(d2))
#
# 딕셔너리의 key값을 이용해서 value값 뽑아내기
# print(d1["key"]) #출력값 => "value"



# d1 = {"apple":"사과","banana":"바나나"}
# #추가
# d1["복숭아"] = "peach"
# #삭제
# del d1["banana"]
# #수정
# d1["apple"] = "수박"
# print(d1) #출력값 => {'apple': '수박', '복숭아': 'peach'}


# d1 = {"A" : 1,"B" : 2,"C" : 3}
# #key값들고 된 자료 만들기
# print(d1.keys())
# #value값들로 된 자료 만들기
# print(d1.values())
#
# print("A" in d1) #출력값 => True

# s1 = ([1,2,3])
# print(s1)
# s2 = set("Hello")
# print(s2)


# s1 = set([1,2,3,4])
# s2 = set([3,4,5])
# s3 = set([6,7,8])
#
# #합집합
# print(s1 | s2)
# print(s2 | s3)
#
# #교집합
# print(s1 & s2)
# print(s2 & s3)
#
# #차집합
# print(s1 - s2)
# print(s2 - s3)

# def solution(phone_book):
#     phone_book.sort()
#     print(phone_book)
#     for i in range(len(phone_book)-1):
#         if phone_book[i] == phone_book[i+1][:len(phone_book[i])]:
#             return False
#     return True
#
# phone_book = ["119", "97674223", "1195524421"]
# print(solution(phone_book))

# d1 = {"한국":"Korea","미국":"America","일본":"Japan"}
# print('Japan' in d1.values())#출력값 => True


# L1 = ["AB","BC","DE"]
# L2 = ["AD","DE","BD"]
# print(set(L1) & set(L2))
